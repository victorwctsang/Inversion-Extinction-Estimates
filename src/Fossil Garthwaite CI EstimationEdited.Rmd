---
title: "Estimating Monte Carlo Confidence Intervals for Fossil Data using Garthwaite 1992"
author: "Victor Tsang"
date: "08/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Assumptions

* Uniform Fossil Recovery: fossil ages are uniformly distributed
* Have an initial point estimate (observed minimum)


### Set parameters

```{r}
set.seed(22)
alpha = 0.05
b = 18000 # upper bound for dates we can get fossils in
```

### Import data

```{r}
library(readxl)
# Import mammoth data from fossildata.xlsx
fossil_dataframe = read_excel(
  path='../data/fossildata.xlsx', 
  sheet="MammothPrimEBer", 
  range="M3:N36", 
  col_names=c("age", "sd"), 
  col_types=c('numeric', 'numeric')
)
fossil_dataframe = fossil_dataframe[fossil_dataframe$age<b,]

n_fossils = length(fossil_dataframe$age)
```


### Functions

```{r}
calc_k = function (alpha) {
  # K := Step length proportionality constant
  # Normal distribution heuristic
  2 / (qnorm(1-alpha) * (2*pi)^(-0.5) * exp(- (qnorm(1-alpha)^2)/2))
}

calc_unbiased_estimator = function (X, b, n) {
  min(X) - (b - min(X))/(n-1)
}

generate_starting_estimates.percentile = function (alpha, theta, n, b) {
  # Implements percentile method (Buckland, 1980; Efron, 1981)
  n.resamples = (2-alpha)/alpha
  fossil.resamples = matrix(runif(n * n.resamples, min=theta, max=b),
                            ncol=n.resamples)
  theta.resamples = apply(fossil.resamples,
                          2,
                          FUN=min)#function (x) calc_unbiased_estimator(x, b, n))
  theta.resamples.sorted = sort(theta.resamples)
  return(list(L=theta.resamples.sorted[2],
              U=theta.resamples.sorted[n.resamples-1],
              m=ceiling(min(50, 0.3 * n.resamples))))
}

rm_process = function (
  bound_vec, theta.hat, n, alpha, b, m, max_iter, k
) {
  for (i in m:max_iter) {
    # Generate resamples
    resamples = runif(n=n, min=bound_vec[i], max=b)
    
    # calculate step length
    c = min(2*k*abs(bound_vec[i] - theta.hat), 1000) # TODO
    
    # Update upper bound
    if (min(resamples) <= theta.hat) {
      bound_vec[i+1] = (bound_vec[i] + c*(1-alpha)/ i)
    } 
    else {
      bound_vec[i+1] = (bound_vec[i] - c*alpha / i)
    }
  }
  return(bound_vec[m:max_iter])
}

getConfidenceInterval.rm_process = function (
  theta.hat, n, alpha, b, m, max_iter, k
) {
  # Starting values
  starting_est = generate_starting_estimates.percentile(alpha, theta.hat, n, b)
  
  bound_lower = bound_upper = rep(NA, max_iter)
  m = starting_est$m
  bound_lower[m] = starting_est$L
  bound_upper[m] = starting_est$U

  # Step length constant k
  lower = rm_process(bound_vec = bound_lower,
                         theta.hat = theta.hat,
                         n = n,
                         alpha = (1-alpha),
                         b = b,
                         m = m,
                         max_iter = max_iter,
                         k = k)
  upper = rm_process(bound_vec = bound_upper,
                         theta.hat = theta.hat,
                         n = n,
                         alpha = alpha,
                         b = b,
                         m = m,
                         max_iter = max_iter,
                         k = k)
  CI.iters = cbind(lower, upper)
  return(list(L=lower[length(lower)],
              U=upper[length(upper)],
              CI.iters=CI.iters))
}
```


### Get point estimate of extinction date

This is just the MLE (the age of the last recorded fossil)

```{r}
obs_stat = min(fossil_dataframe$age)
obs_stat_ub = calc_unbiased_estimator(fossil_dataframe$age, b, n_fossils)
```


### Calculate step length proportionality constant $k's$

We will set $k = 2/\{ z_\alpha (t\pi)^{-1/2}\exp{(-z_\alpha^2/2)}$ where $z_\alpha$ is the upper 100 $\alpha$ % point of the standard normal distribution.

```{r}
k = calc_k(alpha)
k
```


### Select stopping criteria

Some dodgy stuff going on here

```{r}
max_iter = 2000
```


### Select starting values

Generate $(2 - \alpha) / \alpha$ resamples:

```{r}
starting_estimates = generate_starting_estimates.percentile(alpha, obs_stat_ub, n_fossils, b)
starting_estimates
```

We start at the $m$th iteration and set the values to the second largest and second smallest resample:

```{r}
bound_upper = bound_lower = rep(NA,max_iter)

m = starting_estimates$m
bound_lower[m] = starting_estimates$L
bound_upper[m] = starting_estimates$U

bound_lower[m]
bound_upper[m]
```

### RM Process for both upper and lower CI bounds


```{r}
res = getConfidenceInterval.rm_process(obs_stat_ub, n_fossils, alpha, b, m, max_iter, k)
res$U
res$L
```


### Plot iterations

```{r}
plot(res$CI.iters$U,
     pch=4,
     type="l",
     xlab="i",
     col='red',
     ylab=NA,
     main="CI Convergence",
     ylim=c(min(res$CI.iters$L), max(res$CI.iters$U)))
lines(res$CI.iters$L, pch=4, col='blue')
abline(h=obs_stat_ub, col="black")

legend("topright", legend=c("U_i", "L_i", "obs_stat_ub"), col=c("red", "blue", "black"), lty=c(1,1,1))
```




