---
title: "Estimating Monte Carlo Confidence Intervals for Fossil Data using Garthwaite 1992"
author: "Victor Tsang"
date: "08/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Assumptions

* Uniform Fossil Recovery: fossil ages are uniformly distributed
* Normally distributed measurement error
* Have an initial point estimate (observed minimum)

### Set parameters

```{r}
set.seed(22)
alpha = 0.05
K = 18000 # upper bound for dates we can get fossils in
```

### Import data

```{r}
library(readxl)
# Import mammoth data from fossildata.xlsx
fossil_dataframe = read_excel(
  path='../data/fossildata.xlsx', 
  sheet="MammothPrimEBer", 
  range="M3:N36", 
  col_names=c("age", "sd"), 
  col_types=c('numeric', 'numeric')
)
fossil_dataframe = fossil_dataframe[fossil_dataframe$age<K,]

n = length(fossil_dataframe$age)
dating_error.sd = mean(fossil_dataframe$sd)
```


### Functions

```{r}
source("garthwaite-robbins-munro-functions.R")
```


### Get point estimate of extinction date

This is just the MLE (the age of the last recorded fossil)

```{r}
theta.hat.y = min(fossil_dataframe$age)
```


### Calculate step length proportionality constant $k's$

We will set $k = 2/\{ z_\alpha (t\pi)^{-1/2}\exp{(-z_\alpha^2/2)}$ where $z_\alpha$ is the upper 100 $\alpha$ % point of the standard normal distribution.

```{r}
p = calc_prop_constant(alpha)
p
```


### Select stopping criteria

Some dodgy stuff going on here

```{r}
max_iter = 2000
```


### Select starting values

Generate $(2 - \alpha) / \alpha$ resamples:

```{r}
starting_estimates = get_starting_vals(method="percentile", alpha, theta.hat.y, n, K, eps.mean=0, eps.sigma=dating_error.sd)
starting_estimates
```

We start at the $m$th iteration and set the values to the second largest and second smallest resample:

```{r}
bound_upper = bound_lower = rep(NA,max_iter)

m = ceiling(min(50, 0.3 * (2-alpha)/alpha))
bound_lower[m] = starting_estimates[, "lower"]
bound_upper[m] = starting_estimates[, "upper"]

bound_lower[m]
bound_upper[m]
```

### RM Process for both upper and lower CI bounds


```{r}
bound_lower = estimate_bound.rm("lower", bound_lower, alpha, theta.hat.y, n, K, p, m, max_iter, eps.mean=0, eps.sigma=dating_error.sd)
bound_upper = estimate_bound.rm("upper", bound_upper, alpha, theta.hat.y, n, K, p, m, max_iter, eps.mean=0, eps.sigma=dating_error.sd)

CI = list(CI.lower=bound_lower[length(bound_lower)], CI.upper=bound_upper[length(bound_upper)])
CI
```


### Plot iterations

```{r}
plot(na.omit(bound_upper), pch=4, type="l", xlab="i", col='red', ylab=NA, main="CI Convergence",
     ylim=c(min(na.omit(bound_lower)), max(na.omit(bound_upper))))

lines(na.omit(bound_lower), pch=4, col='blue')
abline(h=theta.hat.y, col="black")

legend("topright", legend=c("U_i", "L_i", "observed min"), col=c("red", "blue", "black"), lty=c(1,1,1))
```




