---
title: "Monte Carlo Sample Calculations"
author: "Victor Tsang (z5209633)"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

knitr::knit_hooks$set(timeit = local({
  now = NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res = difftime(Sys.time(), now)
      now <<- NULL
      # use options$label if you want the chunk label as well
      paste('Time for this code chunk:', as.character(res))
    }
  }})
)
```

#### Setup

Source our helper functions and set our parameters.

```{r}
source("minmi-functions.R")

set.seed(2022)

n = 30                             # Number of fossil samples in each dataset
theta.true = 10000                 # True extinction date
K = 20000                          # Upper bound for fossil ages
 
dating_error.mean = 0              # True mean of radiocarbon dating error
dating_error.sd = 272              # True Standard deviation
 
alpha = 0.05                       # 95% confidence interval
```

Then, simulate some data

```{r}
W = runif(n=n, min=theta.true, max=K) + rnorm(n=n, mean=dating_error.mean, sd=dating_error.sd)
m=min(W)
m
```

$$
B = \frac{1}{\mathrm{Var}(\hat\theta_q )} \mathrm{Var} \left\{ \frac{m - e_1^* - \hat\theta_q}{K - e_1^* - \hat\theta_q } \right\} \left[ F_\varepsilon (m - \hat\theta_q) \right]^2 \left[ \hat\theta_q/\hat\psi \right]^2
$$

where $e_b^*$ are samples from distribution with $f_\varepsilon(e_b)$ but right-truncated at $m-\hat\theta_q$

```{r}
find_optimal_B.psi = function (max_var, q, K, m, eps.mean, eps.sigma, B=500) {
  # Initial estimate of theta_q using no measurement error case
  theta_q.hat.init = K - q^(-1/n)*(K-m) 
  
  # Monte carlo samples
  e = rtnorm(B, mean=eps.mean, sd=eps.sigma, a=-Inf, b=m-theta_q.hat.init)
  
  f_eps.K = dnorm(K-theta_q.hat.init, eps.mean, eps.sigma)
  F_eps.K = pnorm(K-theta_q.hat.init, eps.mean, eps.sigma)
  f_eps.m = dnorm(m-theta_q.hat.init, eps.mean, eps.sigma)
  F_eps.m = pnorm(m-theta_q.hat.init, eps.mean, eps.sigma)
  
  sigma2.psi_hat = var((m-e-theta_q.hat.init)/(K-e-theta_q.hat.init))
  psi_hat = mean((m-e-theta_q.hat.init)/(K-e-theta_q.hat.init)) * F_eps.m
  
  max_var^(-1) * sigma2.psi_hat * F_eps.m^2 * (theta_q.hat.init/psi_hat)^2
}
```

```{r timeit = TRUE}
var.theta.target = 225 #(0.2*dating_error.sd)^2

optimal_B.psi = list()
optimal_B.psi$lower = find_optimal_B.psi(max_var=var.theta.target,
                                         q=0.025,
                                         K, m,
                                         dating_error.mean,
                                         dating_error.sd)

optimal_B.psi$upper = find_optimal_B.psi(max_var=var.theta.target,
                                         q=0.975,
                                         K, m,
                                         dating_error.mean,
                                         dating_error.sd)
optimal_B.psi
```

```{r}
all_q = seq(0.01, 1, length.out=100)
all_optimal_B = sapply(all_q, FUN= function(x) find_optimal_B.psi(max_var=var.theta.target, q=x, K, m, dating_error.mean, dating_error.sd))
plot(all_q, all_optimal_B, type="b", main="optimal_B against q", xlab="q", ylab="optimal_B")
```

## Checks

Three things to check expected behaviour:

$$
\mathrm{Var}(\hat\theta_q), \quad \mathrm{Var}\left\{ \frac{m-e-\hat\theta_q}{K-e-\hat\theta_q} \right\}, \quad \left[ \frac{1}{B} \sum_{b=1}^B\frac{m-K}{(K-e_b-\hat\theta_q)^2} \right]^{-2}
$$

### Variance of $\hat\theta_q$

For the purposes of this check, we'll only look at the lower bound estimate.

```{r, timeit = TRUE}
n = 30

B = unique(round(pracma::logseq(2, 2000, 40)))
num.B = length(B)

num.estimates = 50

# Simulate a dataset
W = runif(n=n, min=theta.true, max=K) + rnorm(n=n, mean=dating_error.mean, sd=dating_error.sd)
m=min(W)

var.theta_q = list()
var.theta_q$lower = rep(NA, num.B)
var.theta_q$upper = rep(NA, num.B)

u = matrix(runif(n*num.estimates*B[num.B], min=0, max=1), ncol=B[num.B])

uniroot.interval = c(5000, 19500)
```

```{r, timeit=TRUE, cache=TRUE}
for (i in 1:num.B) {
  # Generate 100 estimates of \theta_0.025
  theta.hat.lower = rep(NA, num.estimates)
  theta.hat.upper = rep(NA, num.estimates)
  for (j in 1:num.estimates) {
    mc.samples = u[((j-1)*n+1):((j)*n), 1:(B[i])]
    theta.hat.lower[j] = estimate_quantile.mc(q=0.025, K, W, mc.samples, 
                                              dating_error.mean, 
                                              dating_error.sd, uniroot.interval)
    theta.hat.upper[j] = estimate_quantile.mc(q=0.975, K, W, mc.samples, 
                                              dating_error.mean, 
                                              dating_error.sd, uniroot.interval)
  }
  # save sample variance
  var.theta_q$lower[i] = var(theta.hat.lower)
  var.theta_q$upper[i] = var(theta.hat.upper)
}
```

```{r}
options(scipen=999)
plot(B, var.theta_q$lower, type="b", col='blue', 
     log = "xy", 
     main="Sample Var(theta_q) against Number of MC Samples",
     ylab=paste("sample variance"), 
     ylim=c(min(c(var.theta_q$lower, var.theta_q$upper)), max(c(var.theta_q$lower, var.theta_q$upper))))
lines(B, var.theta_q$upper, type="b", col='red')
abline(h=var.theta.target, lty=2, col='green')
legend("topright",
       c("q=0.025", "q=0.975"),
       lty=c(1, 1),
       col=c('blue', 'red'))
```

